// Licensed to the Blazor Docs Contributors under one or more agreements.
// The Blazor Docs Contributors licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using Markdig;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

namespace BlazorDocs.SourceGenerators
{
    /// <summary>
    /// The markdown source code generator.
    /// </summary>
    [Generator]
    public class MarkdownSourceGenerator : IIncrementalGenerator
    {
        /// <summary>
        /// Initializes the source code generator.
        /// </summary>
        /// <param name="context">The generator initialization context.</param>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var analyzerConfigOptions = context.AnalyzerConfigOptionsProvider;

            var markdownSourceGeneratorOptions = analyzerConfigOptions
                .Select(ComputeMarkdownSourceGeneratorOptions);

            var sourceItems = context.AdditionalTextsProvider
                .Where(f => f.Path.EndsWith(".md", StringComparison.OrdinalIgnoreCase))
                .Combine(analyzerConfigOptions)
                .Select(ComputeProjectItem);

            var generatedOutput = sourceItems
                .Combine(markdownSourceGeneratorOptions)
                .Select(static (pair, _) =>
                {
                    var (sourceItem, markdownSourceGeneratorOptions) = pair;

                    var hintName = GetIdentifierFromPath(sourceItem.FilePath) + ".g.cs";
                    var csharpDocument = GenerateCode(markdownSourceGeneratorOptions, sourceItem);

                    return (hintName, csharpDocument);
                });

            context.RegisterSourceOutput(generatedOutput, static (context, pair) =>
            {
                var (hintName, csharpDocument) = pair;

                context.AddSource(hintName, csharpDocument);
            });
        }

        /// <summary>
        /// Computes a <see cref="MarkdownSourceGenerationOptions"/>.
        /// </summary>
        /// <param name="options">The <see cref="AnalyzerConfigOptionsProvider"/>.</param>
        /// <param name="cancellationToken">The <see cref="CancellationToken"/>.</param>
        /// <returns>The <see cref="MarkdownSourceGenerationOptions"/>.</returns>
        private static MarkdownSourceGenerationOptions ComputeMarkdownSourceGeneratorOptions(AnalyzerConfigOptionsProvider options, CancellationToken cancellationToken)
        {
            var globalOptions = options.GlobalOptions;

            globalOptions.TryGetValue("build_property.RootNamespace", out var rootNamespace);

            return new MarkdownSourceGenerationOptions()
            {
                RootNamespace = rootNamespace ?? "BlazorDocs"
            };
        }

        /// <summary>
        /// Computes a <see cref="SourceGeneratorProjectItem"/>.
        /// </summary>
        /// <param name="pair">The <see cref="AdditionalText"/> and <see cref="AnalyzerConfigOptionsProvider"/> pair.</param>
        /// <param name="cancellationToken">The <see cref="CancellationToken"/>.</param>
        /// <returns>The <see cref="SourceGeneratorProjectItem"/>.</returns>
        private static SourceGeneratorProjectItem ComputeProjectItem((AdditionalText, AnalyzerConfigOptionsProvider) pair, CancellationToken cancellationToken)
        {
            var (additionalText, globalOptions) = pair;
            var options = globalOptions.GetOptions(additionalText);

            options.TryGetValue("build_property.projectdir", out var projectDir);

            return new SourceGeneratorProjectItem(additionalText, projectDir ?? Path.DirectorySeparatorChar.ToString());
        }

        /// <summary>
        /// Generates code for a markdown file.
        /// </summary>
        /// <param name="options">The <see cref="MarkdownSourceGenerationOptions"/>.</param>
        /// <param name="item">The <see cref="SourceGeneratorProjectItem"/>.</param>
        /// <returns>The resulting code document.</returns>
        private static string GenerateCode(MarkdownSourceGenerationOptions options, SourceGeneratorProjectItem item)
        {
            var builder = new StringBuilder();

            var markdownPipeline = new MarkdownPipelineBuilder()
                .UseAdvancedExtensions()
                .ConfigureNewLine(Environment.NewLine)
                .Build();

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine();
            builder.AppendLine("using Microsoft.AspNetCore.Components;");
            builder.AppendLine("using Microsoft.AspNetCore.Components.Rendering;");
            builder.AppendLine("using Microsoft.JSInterop;");
            builder.AppendLine();
            builder.AppendLine("#pragma warning disable 1591");
            builder.AppendLine($"namespace {GetNamespaceFromPath(options.RootNamespace, item.FilePath)}");
            builder.AppendLine("{");
            builder.AppendLine($"    [Route(\"{GetRouteFromPath(item.FilePath)}\")]");
            builder.AppendLine($"    public class {GetClassNameFromPath(item.FilePath)} : ComponentBase");
            builder.AppendLine("    {");
            builder.AppendLine("        [Inject]");
            builder.AppendLine("        private IJSRuntime js { get; set; }");
            builder.AppendLine();
            builder.AppendLine("        #pragma warning disable 1998");
            builder.AppendLine("        protected override void BuildRenderTree(RenderTreeBuilder builder)");
            builder.AppendLine("        {");
            builder.AppendLine("            builder.AddMarkupContent(0,");
            builder.AppendLine("\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"");
            builder.AppendLine(Markdown.ToHtml(item.MarkdownSourceText, markdownPipeline).Trim(Environment.NewLine.ToArray()));
            builder.AppendLine("\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"");
            builder.AppendLine("            );");
            builder.AppendLine("        }");
            builder.AppendLine("        #pragma warning restore 1998");
            builder.AppendLine();
            builder.AppendLine("        protected override async Task OnAfterRenderAsync(bool firstR66ender)");
            builder.AppendLine("        {");
            builder.AppendLine("            await js.InvokeVoidAsync(\"Prism.highlightAll\");");
            builder.AppendLine("        }");
            builder.AppendLine("    }");
            builder.AppendLine("}");
            builder.AppendLine("#pragma warning restore 1591");

            return builder.ToString();
        }

        /// <summary>
        /// Gets a file identifier by the file path.
        /// </summary>
        /// <param name="filePath">The path to the file.</param>
        /// <returns>The identifier.</returns>
        private static string GetIdentifierFromPath(string filePath)
        {
            var builder = new StringBuilder();

            for (var i = 0; i < filePath.Length; i++)
            {
                switch (filePath[i])
                {
                    case '\\' or '/':
                    case char ch when !char.IsLetterOrDigit(ch):
                        builder.Append('_');
                        break;
                    default:
                        builder.Append(filePath[i]);
                        break;
                }
            }

            return builder.ToString();
        }

        /// <summary>
        /// Gets a namespace by the root namespace and file path.
        /// </summary>
        /// <param name="rootNamespace">The root namespace.</param>
        /// <param name="filePath">The path to the file.</param>
        /// <returns>The namespace.</returns>
        private static string GetNamespaceFromPath(string rootNamespace, string filePath)
        {
            var builder = new StringBuilder();

            var directory = Path.GetDirectoryName(filePath);

            for (var i = 0; i < directory.Length; i++)
            {
                switch (directory[i])
                {
                    case '\\' or '/':
                        builder.Append('.');
                        break;
                    case char ch when !char.IsLetterOrDigit(ch):
                        builder.Append('_');
                        break;
                    default:
                        builder.Append(directory[i]);
                        break;
                }
            }

            var fileNamespace = builder.ToString();

            if (string.IsNullOrEmpty(fileNamespace))
            {
                return rootNamespace;
            }
            else
            {
                return $"{rootNamespace}.{fileNamespace}";
            }
        }

        /// <summary>
        /// Gets a class name by the file path.
        /// </summary>
        /// <param name="filePath">The path to the file.</param>
        /// <returns>The class name.</returns>
        private static string GetClassNameFromPath(string filePath)
        {
            var builder = new StringBuilder();

            var fileName = Path.GetFileNameWithoutExtension(filePath);

            for (var i = 0; i < fileName.Length; i++)
            {
                switch (fileName[i])
                {
                    case char ch when !char.IsLetterOrDigit(ch):
                        builder.Append('_');
                        break;
                    default:
                        builder.Append(fileName[i]);
                        break;
                }
            }

            return builder.ToString();
        }

        /// <summary>
        /// Gets a route by the file path.
        /// </summary>
        /// <param name="filePath">The path to the file.</param>
        /// <returns>The route.</returns>
        private static string GetRouteFromPath(string filePath)
        {
            var builder = new StringBuilder("/");

            var directory = Path.GetDirectoryName(filePath).ToLower();
            var fileName = Path.GetFileNameWithoutExtension(filePath).ToLower();

            for (var i = 0; i < directory.Length; i++)
            {
                switch (directory[i])
                {
                    case '\\' or '/':
                        builder.Append('/');
                        break;
                    case char ch when !char.IsLetterOrDigit(ch):
                        builder.Append('_');
                        break;
                    default:
                        builder.Append(directory[i]);
                        break;
                }
            }

            if (fileName != "index")
            {
                builder.Append('/');

                for (var i = 0; i < fileName.Length; i++)
                {
                    switch (fileName[i])
                    {
                        case char ch when !char.IsLetterOrDigit(ch):
                            builder.Append('-');
                            break;
                        default:
                            builder.Append(fileName[i]);
                            break;
                    }
                }
            }

            return builder.ToString();
        }
    }
}
